35a36,47
> namespace math
> {
>     constexpr simd::float3 add( const simd::float3& a, const simd::float3& b );
>     constexpr simd_float4x4 makeIdentity();
>     simd::float4x4 makePerspective();
>     simd::float4x4 makeXRotate( float angleRadians );
>     simd::float4x4 makeYRotate( float angleRadians );
>     simd::float4x4 makeZRotate( float angleRadians );
>     simd::float4x4 makeTranslate( const simd::float3& v );
>     simd::float4x4 makeScale( const simd::float3& v );
> }
> 
41a54
>         void buildDepthStencilStates();
49a63
>         MTL::DepthStencilState* _pDepthStencilState;
51a66
>         MTL::Buffer* _pCameraDataBuffer[kMaxFramesInFlight];
182c197,199
<     _pMtkView->setClearColor( MTL::ClearColor::Make( 1.0, 0.0, 0.0, 1.0 ) );
---
>     _pMtkView->setClearColor( MTL::ClearColor::Make( 0.1, 0.1, 0.1, 1.0 ) );
>     _pMtkView->setDepthStencilPixelFormat( MTL::PixelFormat::PixelFormatDepth16Unorm );
>     _pMtkView->setClearDepth( 1.0f );
188c205
<     _pWindow->setTitle( NS::String::string( "04 - Instancing", NS::StringEncoding::UTF8StringEncoding ) );
---
>     _pWindow->setTitle( NS::String::string( "05 - Perspective", NS::StringEncoding::UTF8StringEncoding ) );
225a243,324
> #pragma mark - Math
> 
> namespace math
> {
>     constexpr simd::float3 add( const simd::float3& a, const simd::float3& b )
>     {
>         return { a.x + b.x, a.y + b.y, a.z + b.z };
>     }
> 
>     constexpr simd_float4x4 makeIdentity()
>     {
>         using simd::float4;
>         return (simd_float4x4){ (float4){ 1.f, 0.f, 0.f, 0.f },
>                                 (float4){ 0.f, 1.f, 0.f, 0.f },
>                                 (float4){ 0.f, 0.f, 1.f, 0.f },
>                                 (float4){ 0.f, 0.f, 0.f, 1.f } };
>     }
> 
>     simd::float4x4 makePerspective( float fovRadians, float aspect, float znear, float zfar )
>     {
>         using simd::float4;
>         float ys = 1.f / tanf(fovRadians * 0.5f);
>         float xs = ys / aspect;
>         float zs = zfar / ( znear - zfar );
>         return simd_matrix_from_rows((float4){ xs, 0.0f, 0.0f, 0.0f },
>                                      (float4){ 0.0f, ys, 0.0f, 0.0f },
>                                      (float4){ 0.0f, 0.0f, zs, znear * zs },
>                                      (float4){ 0, 0, -1, 0 });
>     }
> 
>     simd::float4x4 makeXRotate( float angleRadians )
>     {
>         using simd::float4;
>         const float a = angleRadians;
>         return simd_matrix_from_rows((float4){ 1.0f, 0.0f, 0.0f, 0.0f },
>                                      (float4){ 0.0f, cosf( a ), sinf( a ), 0.0f },
>                                      (float4){ 0.0f, -sinf( a ), cosf( a ), 0.0f },
>                                      (float4){ 0.0f, 0.0f, 0.0f, 1.0f });
>     }
> 
>     simd::float4x4 makeYRotate( float angleRadians )
>     {
>         using simd::float4;
>         const float a = angleRadians;
>         return simd_matrix_from_rows((float4){ cosf( a ), 0.0f, sinf( a ), 0.0f },
>                                      (float4){ 0.0f, 1.0f, 0.0f, 0.0f },
>                                      (float4){ -sinf( a ), 0.0f, cosf( a ), 0.0f },
>                                      (float4){ 0.0f, 0.0f, 0.0f, 1.0f });
>     }
> 
>     simd::float4x4 makeZRotate( float angleRadians )
>     {
>         using simd::float4;
>         const float a = angleRadians;
>         return simd_matrix_from_rows((float4){ cosf( a ), sinf( a ), 0.0f, 0.0f },
>                                      (float4){ -sinf( a ), cosf( a ), 0.0f, 0.0f },
>                                      (float4){ 0.0f, 0.0f, 1.0f, 0.0f },
>                                      (float4){ 0.0f, 0.0f, 0.0f, 1.0f });
>     }
> 
>     simd::float4x4 makeTranslate( const simd::float3& v )
>     {
>         using simd::float4;
>         const float4 col0 = { 1.0f, 0.0f, 0.0f, 0.0f };
>         const float4 col1 = { 0.0f, 1.0f, 0.0f, 0.0f };
>         const float4 col2 = { 0.0f, 0.0f, 1.0f, 0.0f };
>         const float4 col3 = { v.x, v.y, v.z, 1.0f };
>         return simd_matrix( col0, col1, col2, col3 );
>     }
> 
>     simd::float4x4 makeScale( const simd::float3& v )
>     {
>         using simd::float4;
>         return simd_matrix((float4){ v.x, 0, 0, 0 },
>                            (float4){ 0, v.y, 0, 0 },
>                            (float4){ 0, 0, v.z, 0 },
>                            (float4){ 0, 0, 0, 1.0 });
>     }
> 
> }
> 
> 
237a337
>     buildDepthStencilStates();
245a346
>     _pDepthStencilState->release();
250a352,355
>     for ( int i = 0; i < kMaxFramesInFlight; ++i )
>     {
>         _pCameraDataBuffer[i]->release();
>     }
263a369,374
> 
>     struct CameraData
>     {
>         simd::float4x4 perspectiveTransform;
>         simd::float4x4 worldTransform;
>     };
290a402,407
>         struct CameraData
>         {
>             float4x4 perspectiveTransform;
>             float4x4 worldTransform;
>         };
> 
292a410
>                                device const CameraData& cameraData [[buffer(2)]],
298c416,418
<             o.position = instanceData[ instanceId ].instanceTransform * pos;
---
>             pos = instanceData[ instanceId ].instanceTransform * pos;
>             pos = cameraData.perspectiveTransform * cameraData.worldTransform * pos;
>             o.position = pos;
323a444
>     pDesc->setDepthAttachmentPixelFormat( MTL::PixelFormat::PixelFormatDepth16Unorm );
337a459,469
> void Renderer::buildDepthStencilStates()
> {
>     MTL::DepthStencilDescriptor* pDsDesc = MTL::DepthStencilDescriptor::alloc()->init();
>     pDsDesc->setDepthCompareFunction( MTL::CompareFunction::CompareFunctionLess );
>     pDsDesc->setDepthWriteEnabled( true );
> 
>     _pDepthStencilState = _pDevice->newDepthStencilState( pDsDesc );
> 
>     pDsDesc->release();
> }
> 
341d472
< 
348c479,484
<         { -s, +s, +s }
---
>         { -s, +s, +s },
> 
>         { -s, -s, -s },
>         { -s, +s, -s },
>         { +s, +s, -s },
>         { +s, -s, -s }
352c488
<         0, 1, 2,
---
>         0, 1, 2, /* front */
353a490,504
> 
>         1, 7, 6, /* right */
>         6, 2, 1,
> 
>         7, 4, 5, /* back */
>         5, 6, 7,
> 
>         4, 0, 3, /* left */
>         3, 5, 4,
> 
>         3, 2, 6, /* top */
>         6, 5, 3,
> 
>         4, 7, 1, /* bottom */
>         1, 0, 4
375a527,532
> 
>     const size_t cameraDataSize = kMaxFramesInFlight * sizeof( shader_types::CameraData );
>     for ( size_t i = 0; i < kMaxFramesInFlight; ++i )
>     {
>         _pCameraDataBuffer[ i ] = _pDevice->newBuffer( cameraDataSize, MTL::ResourceStorageModeManaged );
>     }
379a537
>     using simd::float3;
398a557,566
> 
>     float3 objectPosition = { 0.f, 0.f, -5.f };
> 
>     // Update instance positions:
> 
>     float4x4 rt = math::makeTranslate( objectPosition );
>     float4x4 rr = math::makeYRotate( -_angle );
>     float4x4 rtInv = math::makeTranslate( { -objectPosition.x, -objectPosition.y, -objectPosition.z } );
>     float4x4 fullObjectRot = rt * rr * rtInv;
> 
402c570
<         float xoff = (iDivNumInstances * 2.0f - 1.0f) + (1.f/kNumInstances);
---
>         float xoff = (iDivNumInstances * 2.20f - 1.0f) + (1.f/kNumInstances);
404,407c572,579
<         pInstanceData[ i ].instanceTransform = (float4x4){ (float4){ scl * sinf(_angle), scl * cosf(_angle), 0.f, 0.f },
<                                                            (float4){ scl * cosf(_angle), scl * -sinf(_angle), 0.f, 0.f },
<                                                            (float4){ 0.f, 0.f, scl, 0.f },
<                                                            (float4){ xoff, yoff, 0.f, 1.f } };
---
> 
>         // Use the tiny math library to apply a 3D transformation to the instance.
>         float4x4 scale = math::makeScale( (float3){ scl, scl, scl } );
>         float4x4 zrot = math::makeZRotate( _angle );
>         float4x4 yrot = math::makeYRotate( _angle );
>         float4x4 translate = math::makeTranslate( math::add( objectPosition, { xoff, yoff, 0.f } ) );
> 
>         pInstanceData[ i ].instanceTransform = fullObjectRot * translate * yrot * zrot * scale;
415a588,596
>     // Update camera state:
> 
>     MTL::Buffer* pCameraDataBuffer = _pCameraDataBuffer[ _frame ];
>     shader_types::CameraData* pCameraData = reinterpret_cast< shader_types::CameraData *>( pCameraDataBuffer->contents() );
>     pCameraData->perspectiveTransform = math::makePerspective( 45.f * M_PI / 180.f, 1.f, 0.03f, 500.0f ) ;
>     pCameraData->worldTransform = math::makeIdentity();
>     pCameraDataBuffer->didModifyRange( NS::Range::Make( 0, sizeof( shader_types::CameraData ) ) );
> 
>     // Begin render pass:
420a602,603
>     pEnc->setDepthStencilState( _pDepthStencilState );
> 
422a606,609
>     pEnc->setVertexBuffer( pCameraDataBuffer, /* offset */ 0, /* index */ 2 );
> 
>     pEnc->setCullMode( MTL::CullModeBack );
>     pEnc->setFrontFacingWinding( MTL::Winding::WindingCounterClockwise );
424,426d610
<     //
<     // void drawIndexedPrimitives( PrimitiveType primitiveType, NS::UInteger indexCount, IndexType indexType,
<     //                             const class Buffer* pIndexBuffer, NS::UInteger indexBufferOffset, NS::UInteger instanceCount );
428c612
<                                 6, MTL::IndexType::IndexTypeUInt16,
---
>                                 6 * 6, MTL::IndexType::IndexTypeUInt16,
